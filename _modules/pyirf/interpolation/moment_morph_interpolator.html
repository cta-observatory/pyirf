

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyirf.interpolation.moment_morph_interpolator &mdash; pyirf  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />

  
    <link rel="canonical" href="https://pyirf.readthedocs.io/_modules/pyirf/interpolation/moment_morph_interpolator.html"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            pyirf
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction to <code class="docutils literal notranslate"><span class="pre">pyirf</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../notebooks/index.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">How to contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../AUTHORS.html">Authors</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../irf/index.html">Instrument Response Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sensitivity.html">Sensitivity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../benchmarks/index.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cuts.html">Calculating and Applying Cuts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cut_optimization.html">Cut Optimization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../simulation.html">Simulation Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../spectral.html">Event Weighting and Spectrum Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../binning.html">Binning and Histogram Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../io/index.html">Input / Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../interpolation.html">Interpolation and Extrapolation of IRFs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gammapy.html">Gammapy Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../utils.html">Utility functions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">pyirf</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pyirf.interpolation.moment_morph_interpolator</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pyirf.interpolation.moment_morph_interpolator</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyirf.binning</span><span class="w"> </span><span class="kn">import</span> <span class="n">bin_center</span><span class="p">,</span> <span class="n">calculate_bin_indices</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.base_interpolators</span><span class="w"> </span><span class="kn">import</span> <span class="n">DiscretePDFInterpolator</span><span class="p">,</span> <span class="n">PDFNormalization</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_bin_width</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;MomentMorphInterpolator&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_estimate_mean_std</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="p">,</span> <span class="n">normalization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to roughly estimate mean and standard deviation from a histogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bin_edges: np.ndarray, shape=(n_bins+1)</span>
<span class="sd">        Array of common bin-edges for binned_pdf</span>
<span class="sd">    binned_pdf: np.ndarray, shape=(n_points, ..., n_bins)</span>
<span class="sd">        PDF values from which to compute mean and std</span>
<span class="sd">    normalization : PDFNormalization</span>
<span class="sd">        How the PDF is normalized</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mean: np.ndarray, shape=(n_points, ...)</span>
<span class="sd">        Estimated mean for each input template</span>
<span class="sd">    std: np.ndarray, shape=(n_points, ...)</span>
<span class="sd">        Estimated standard deviation for each input template. Set to width/2 if only one bin in</span>
<span class="sd">        the input template is =/= 0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create an 2darray where the 1darray mids is repeated n_template times</span>
    <span class="n">mids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">bin_center</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span> <span class="n">binned_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">width</span> <span class="o">=</span> <span class="n">get_bin_width</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">normalization</span><span class="p">)</span>

    <span class="c1"># integrate pdf to get probability in each bin</span>
    <span class="n">probability</span> <span class="o">=</span> <span class="n">binned_pdf</span> <span class="o">*</span> <span class="n">width</span>
    <span class="c1"># Weighted averages to compute mean and std</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">mids</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">((</span><span class="n">mids</span> <span class="o">-</span> <span class="n">mean</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">probability</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Set std to 0.5*width for all those templates that have only one bin =/= 0. In those</span>
    <span class="c1"># cases mids-mean = 0 and therefore std = 0. Uses the width of the one bin with</span>
    <span class="c1"># binned_pdf!=0</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">std</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="c1"># std of a uniform distribution inside the bin</span>
        <span class="n">uniform_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">std</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform_std</span><span class="p">[</span><span class="n">binned_pdf</span><span class="p">[</span><span class="n">mask</span><span class="p">,</span> <span class="p">:]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">std</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_lookup</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to return the bin-height at a desired point.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bin_edges: np.ndarray, shape=(n_bins+1)</span>
<span class="sd">        Array of common bin-edges for binned_pdf</span>
<span class="sd">    binned_pdf: np.ndarray, shape=(n_points, ..., n_bins)</span>
<span class="sd">        Array of bin-entries, actual</span>
<span class="sd">    x: numpy.ndarray, shape=(n_points, ..., n_bins)</span>
<span class="sd">        Array of n_bins points for each input template, where the histogram-value (bin-height) should be found</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y: numpy.ndarray, shape=(n_points, ..., n_bins)</span>
<span class="sd">        Array of the bin-heights at the n_bins points x, set to 0 at each point outside the histogram</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the bin where each point x is located in</span>
    <span class="n">binnr</span><span class="p">,</span> <span class="n">valid</span> <span class="o">=</span> <span class="n">calculate_bin_indices</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">)</span>

    <span class="c1"># Set under/overflow-bins (invalid bins) to 0 to avoid errors below</span>
    <span class="n">binnr</span><span class="p">[</span><span class="o">~</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Loop over every combination of flattend input histograms and flattend binning</span>
    <span class="n">lu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">cont</span><span class="p">[</span><span class="n">binnr_row</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">cont</span><span class="p">,</span> <span class="n">binnr_row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">binned_pdf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                <span class="n">binnr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">binnr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">binned_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Set all invalid bins to 0</span>
    <span class="n">lu</span><span class="p">[</span><span class="o">~</span><span class="n">valid</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Set under-/ overflowbins to 0, reshape to original shape</span>
    <span class="k">return</span> <span class="n">lu</span>


<span class="k">def</span><span class="w"> </span><span class="nf">linesegment_1D_interpolation_coefficients</span><span class="p">(</span><span class="n">grid_points</span><span class="p">,</span> <span class="n">target_point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute 1D interpolation coefficients for moment morph interpolation,</span>
<span class="sd">    as in eq. (6) of [1]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid_points: np.ndarray, shape=(2, 1)</span>
<span class="sd">        Points spanning a triangle in which</span>
<span class="sd">    target_point: numpy.ndarray, shape=(1, 1)</span>
<span class="sd">        Value at which the histogram should be interpolated</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients: numpy.ndarray, shape=(2,)</span>
<span class="sd">        Interpolation coefficients for all three interpolation simplex vertices</span>
<span class="sd">        to interpolate to the target_point</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Baak, S. Gadatsch, R. Harrington and W. Verkerke (2015). Interpolation between</span>
<span class="sd">           multi-dimensional histograms using a new non-linear moment morphing method</span>
<span class="sd">           Nucl. Instrum. Methods Phys. Res. A 771, 39-48. https://doi.org/10.1016/j.nima.2014.10.033</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set zeroth grid point as reference value</span>
    <span class="n">m0</span> <span class="o">=</span> <span class="n">grid_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Compute matrix M as in eq. (2) of [1]</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">grid_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">m_ij</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_points</span> <span class="o">-</span> <span class="n">m0</span><span class="p">)</span> <span class="o">**</span> <span class="n">j</span>

    <span class="c1"># Compute coefficients, eq. (6) from [1]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...j, ji -&gt; ...i&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">target_point</span> <span class="o">-</span> <span class="n">m0</span><span class="p">)</span> <span class="o">**</span> <span class="n">j</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">m_ij</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">barycentric_2D_interpolation_coefficients</span><span class="p">(</span><span class="n">grid_points</span><span class="p">,</span> <span class="n">target_point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute barycentric 2D interpolation coefficients for triangular</span>
<span class="sd">    interpolation, see e.g. [1]</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid_points: np.ndarray, shape=(3, 2)</span>
<span class="sd">        Points spanning a triangle in which</span>
<span class="sd">    target_point: np.ndarray, shape=(1, 2)</span>
<span class="sd">        Value at which barycentric interpolation is needed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coefficients: numpy.ndarray, shape=(3,)</span>
<span class="sd">        Interpolation coefficients for all three interpolation simplex vertices</span>
<span class="sd">        to interpolate to the target_point</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] https://codeplea.com/triangular-interpolation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute distance vectors between the grid points</span>
    <span class="n">d13</span> <span class="o">=</span> <span class="n">grid_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">grid_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">d23</span> <span class="o">=</span> <span class="n">grid_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">grid_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Compute distance vector between target and third grid point</span>
    <span class="n">dp3</span> <span class="o">=</span> <span class="n">target_point</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="o">-</span> <span class="n">grid_points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Compute first and second weight</span>
    <span class="n">w1</span> <span class="o">=</span> <span class="p">((</span><span class="n">d23</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">d23</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp3</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">d23</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d13</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">d23</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d13</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">w2</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="n">d13</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">d13</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dp3</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">d23</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">d13</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">d23</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">d13</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="c1"># Use w1+w2+w3 = 1 for third weight</span>
    <span class="n">w3</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">w1</span> <span class="o">-</span> <span class="n">w2</span>

    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">,</span> <span class="n">w3</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">coefficients</span>


<span class="k">def</span><span class="w"> </span><span class="nf">moment_morph_estimation</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="p">,</span> <span class="n">coefficients</span><span class="p">,</span> <span class="n">normalization</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that wraps up the moment morph procedure [1] adopted for histograms.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bin_edges: np.ndarray, shape=(n_bins+1)</span>
<span class="sd">        Array of common bin-edges for binned_pdf</span>
<span class="sd">    binned_pdf: np.ndarray, shape=(n_points, ..., n_bins)</span>
<span class="sd">        Array of bin-entries, actual</span>
<span class="sd">    coefficients: np.ndarray, shape=(n_points)</span>
<span class="sd">        Estimation coefficients for each entry in binned_pdf</span>
<span class="sd">    normalization : PDFNormalization</span>
<span class="sd">        How the PDF is normalized</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f_new: numpy.ndarray, shape=(1, n_bins)</span>
<span class="sd">        Interpolated histogram</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] M. Baak, S. Gadatsch, R. Harrington and W. Verkerke (2015). Interpolation between</span>
<span class="sd">           multi-dimensional histograms using a new non-linear moment morphing method</span>
<span class="sd">           Nucl. Instrum. Methods Phys. Res. A 771, 39-48. https://doi.org/10.1016/j.nima.2014.10.033</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_mids</span> <span class="o">=</span> <span class="n">bin_center</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>

    <span class="c1"># Catch all those templates, where at least one template histogram is all zeros.</span>
    <span class="n">zero_templates</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">binned_pdf</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Manipulate those templates so that computations pass without error</span>
    <span class="n">binned_pdf</span><span class="p">[:,</span> <span class="n">zero_templates</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_mids</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_mids</span><span class="p">))</span>

    <span class="c1"># Estimate mean and std for each input template histogram. First adaption needed to extend</span>
    <span class="c1"># the moment morph procedure to histograms</span>
    <span class="n">mus</span><span class="p">,</span> <span class="n">sigs</span> <span class="o">=</span> <span class="n">_estimate_mean_std</span><span class="p">(</span>
        <span class="n">bin_edges</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="o">=</span><span class="n">binned_pdf</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">normalization</span>
    <span class="p">)</span>
    <span class="n">coefficients</span> <span class="o">=</span> <span class="n">coefficients</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">binned_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">mus</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Transform mean and std as in eq. (11) and (12) in [1]</span>
    <span class="c1"># cs = np.broadcast_to(cs, mus.shape)</span>
    <span class="n">mu_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coefficients</span> <span class="o">*</span> <span class="n">mus</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">sig_prime</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">coefficients</span> <span class="o">*</span> <span class="n">sigs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute slope and offset as in eq. (14) and (15) in [1]</span>
    <span class="n">aij</span> <span class="o">=</span> <span class="n">sigs</span> <span class="o">/</span> <span class="n">sig_prime</span>
    <span class="n">bij</span> <span class="o">=</span> <span class="n">mus</span> <span class="o">-</span> <span class="n">mu_prime</span> <span class="o">*</span> <span class="n">aij</span>

    <span class="c1"># Transformation as in eq. (13) in [1]</span>
    <span class="n">mids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">bin_mids</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">transf_mids</span> <span class="o">=</span> <span class="n">aij</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">mids</span> <span class="o">+</span> <span class="n">bij</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="c1"># Compute the morphed historgram according to eq. (18) in [1]. The function &quot;lookup&quot; &quot;resamples&quot;</span>
    <span class="c1"># the histogram at the transformed bin-mids by using the templates historgam value at the transformed</span>
    <span class="c1"># bin-mid as new value for a whole transformed bin. Second adaption needed to extend</span>
    <span class="c1"># the moment morph procedure to histograms, adaptes the behaviour of eq. (16)</span>

    <span class="n">transf_hist</span> <span class="o">=</span> <span class="n">_lookup</span><span class="p">(</span><span class="n">bin_edges</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="o">=</span><span class="n">binned_pdf</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">transf_mids</span><span class="p">)</span>

    <span class="n">f_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">coefficients</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">transf_hist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">aij</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="c1"># Reset interpolation resolts for those templates with partially zero entries from above to 0</span>
    <span class="n">f_new</span><span class="p">[</span><span class="n">zero_templates</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_mids</span><span class="p">))</span>

    <span class="c1"># Re-Normalize, needed, as the estimation of the std used above is not exact but the result is scaled with</span>
    <span class="c1"># the estimated std</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">get_bin_width</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">normalization</span><span class="p">)</span>
    <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f_new</span> <span class="o">*</span> <span class="n">bin_widths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">f_new</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">f_new</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">norm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">binned_pdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">)</span>


<div class="viewcode-block" id="MomentMorphInterpolator">
<a class="viewcode-back" href="../../../api/pyirf.interpolation.MomentMorphInterpolator.html#pyirf.interpolation.MomentMorphInterpolator">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MomentMorphInterpolator</span><span class="p">(</span><span class="n">DiscretePDFInterpolator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Interpolator class providing Moment Morphing to interpolate discretized PDFs.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">grid_points</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">PDFNormalization</span><span class="o">.</span><span class="n">AREA</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolator class using moment morphing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid_points: np.ndarray, shape=(n_points, n_dims)</span>
<span class="sd">            Grid points at which interpolation templates exist. May be one ot two dimensional.</span>
<span class="sd">        bin_edges: np.ndarray, shape=(n_bins+1)</span>
<span class="sd">            Edges of the data binning</span>
<span class="sd">        binned_pdf: np.ndarray, shape=(n_points, ..., n_bins)</span>
<span class="sd">            Content of each bin in bin_edges for</span>
<span class="sd">            each point in grid_points. First dimesion has to correspond to number</span>
<span class="sd">            of grid_points. Interpolation dimension, meaning the</span>
<span class="sd">            the quantity that should be interpolated (e.g. the Migra axis for EDisp)</span>
<span class="sd">            has to be at axis specified by axis-keyword as well as having entries</span>
<span class="sd">            corresponding to the number of bins given through bin_edges keyword.</span>
<span class="sd">        normalization : PDFNormalization</span>
<span class="sd">            How the PDF is normalized</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">            Also calls pyirf.interpolation.DiscretePDFInterpolator.__init__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grid_points</span><span class="p">,</span> <span class="n">bin_edges</span><span class="p">,</span> <span class="n">binned_pdf</span><span class="p">,</span> <span class="n">normalization</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">triangulation</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_dim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Interpolation in more then two dimension not impemented.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_interpolate1D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find target inside 1D self.grid_points and interpolate</span>
<span class="sd">        on this subset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">target_point</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_points</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span>
        <span class="n">segment_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">target_bin</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">target_bin</span><span class="p">],</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">linesegment_1D_interpolation_coefficients</span><span class="p">(</span>
            <span class="n">grid_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_points</span><span class="p">[</span><span class="n">segment_inds</span><span class="p">],</span>
            <span class="n">target_point</span><span class="o">=</span><span class="n">target_point</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">moment_morph_estimation</span><span class="p">(</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
            <span class="n">binned_pdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_pdf</span><span class="p">[</span><span class="n">segment_inds</span><span class="p">],</span>
            <span class="n">coefficients</span><span class="o">=</span><span class="n">coefficients</span><span class="p">,</span>
            <span class="n">normalization</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalization</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_interpolate2D</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to find target inside 2D self.grid_points and interpolate</span>
<span class="sd">        on this subset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">simplex_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">triangulation</span><span class="o">.</span><span class="n">simplices</span><span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">triangulation</span><span class="o">.</span><span class="n">find_simplex</span><span class="p">(</span><span class="n">target_point</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">barycentric_2D_interpolation_coefficients</span><span class="p">(</span>
            <span class="n">grid_points</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_points</span><span class="p">[</span><span class="n">simplex_inds</span><span class="p">],</span>
            <span class="n">target_point</span><span class="o">=</span><span class="n">target_point</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">moment_morph_estimation</span><span class="p">(</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
            <span class="n">binned_pdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binned_pdf</span><span class="p">[</span><span class="n">simplex_inds</span><span class="p">],</span>
            <span class="n">coefficients</span><span class="o">=</span><span class="n">coefficients</span><span class="p">,</span>
            <span class="n">normalization</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalization</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="MomentMorphInterpolator.interpolate">
<a class="viewcode-back" href="../../../api/pyirf.interpolation.MomentMorphInterpolator.html#pyirf.interpolation.MomentMorphInterpolator.interpolate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_point</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a grid of binned pdfs for a bunch of different parameters</span>
<span class="sd">        and interpolates it to given value of those parameters.</span>
<span class="sd">        This function calls implementations of the moment morphing interpolation</span>
<span class="sd">        pocedure introduced in [1].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_point: numpy.ndarray, shape=(1, n_dims)</span>
<span class="sd">            Value for which the interpolation is performed (target point)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f_new: numpy.ndarray, shape=(1,...,n_bins)</span>
<span class="sd">            Interpolated and binned pdf</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] M. Baak, S. Gadatsch, R. Harrington and W. Verkerke (2015). Interpolation between</span>
<span class="sd">               multi-dimensional histograms using a new non-linear moment morphing method</span>
<span class="sd">               Nucl. Instrum. Methods Phys. Res. A 771, 39-48. https://doi.org/10.1016/j.nima.2014.10.033</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">interpolant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate1D</span><span class="p">(</span><span class="n">target_point</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">interpolant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolate2D</span><span class="p">(</span><span class="n">target_point</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">interpolant</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Maximilian Nöthe, Michele Peresano, Thomas Vuillaume.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>